{"version":3,"file":"js/267.3e3d36c3d9b123d5cd5b.js","mappings":"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","sources":["webpack://hezx/./node_modules/.pnpm/@lezer+markdown@1.4.3/node_modules/@lezer/markdown/dist/index.js"],"sourcesContent":["import { NodeType, NodeProp, NodeSet, Tree, Parser, parseMixed } from '@lezer/common';\nimport { styleTags, tags, Tag } from '@lezer/highlight';\n\nclass CompositeBlock {\n    static create(type, value, from, parentHash, end) {\n        let hash = (parentHash + (parentHash << 8) + type + (value << 4)) | 0;\n        return new CompositeBlock(type, value, from, hash, end, [], []);\n    }\n    constructor(type, \n    // Used for indentation in list items, markup character in lists\n    value, from, hash, end, children, positions) {\n        this.type = type;\n        this.value = value;\n        this.from = from;\n        this.hash = hash;\n        this.end = end;\n        this.children = children;\n        this.positions = positions;\n        this.hashProp = [[NodeProp.contextHash, hash]];\n    }\n    addChild(child, pos) {\n        if (child.prop(NodeProp.contextHash) != this.hash)\n            child = new Tree(child.type, child.children, child.positions, child.length, this.hashProp);\n        this.children.push(child);\n        this.positions.push(pos);\n    }\n    toTree(nodeSet, end = this.end) {\n        let last = this.children.length - 1;\n        if (last >= 0)\n            end = Math.max(end, this.positions[last] + this.children[last].length + this.from);\n        return new Tree(nodeSet.types[this.type], this.children, this.positions, end - this.from).balance({\n            makeTree: (children, positions, length) => new Tree(NodeType.none, children, positions, length, this.hashProp)\n        });\n    }\n}\nvar Type;\n(function (Type) {\n    Type[Type[\"Document\"] = 1] = \"Document\";\n    Type[Type[\"CodeBlock\"] = 2] = \"CodeBlock\";\n    Type[Type[\"FencedCode\"] = 3] = \"FencedCode\";\n    Type[Type[\"Blockquote\"] = 4] = \"Blockquote\";\n    Type[Type[\"HorizontalRule\"] = 5] = \"HorizontalRule\";\n    Type[Type[\"BulletList\"] = 6] = \"BulletList\";\n    Type[Type[\"OrderedList\"] = 7] = \"OrderedList\";\n    Type[Type[\"ListItem\"] = 8] = \"ListItem\";\n    Type[Type[\"ATXHeading1\"] = 9] = \"ATXHeading1\";\n    Type[Type[\"ATXHeading2\"] = 10] = \"ATXHeading2\";\n    Type[Type[\"ATXHeading3\"] = 11] = \"ATXHeading3\";\n    Type[Type[\"ATXHeading4\"] = 12] = \"ATXHeading4\";\n    Type[Type[\"ATXHeading5\"] = 13] = \"ATXHeading5\";\n    Type[Type[\"ATXHeading6\"] = 14] = \"ATXHeading6\";\n    Type[Type[\"SetextHeading1\"] = 15] = \"SetextHeading1\";\n    Type[Type[\"SetextHeading2\"] = 16] = \"SetextHeading2\";\n    Type[Type[\"HTMLBlock\"] = 17] = \"HTMLBlock\";\n    Type[Type[\"LinkReference\"] = 18] = \"LinkReference\";\n    Type[Type[\"Paragraph\"] = 19] = \"Paragraph\";\n    Type[Type[\"CommentBlock\"] = 20] = \"CommentBlock\";\n    Type[Type[\"ProcessingInstructionBlock\"] = 21] = \"ProcessingInstructionBlock\";\n    // Inline\n    Type[Type[\"Escape\"] = 22] = \"Escape\";\n    Type[Type[\"Entity\"] = 23] = \"Entity\";\n    Type[Type[\"HardBreak\"] = 24] = \"HardBreak\";\n    Type[Type[\"Emphasis\"] = 25] = \"Emphasis\";\n    Type[Type[\"StrongEmphasis\"] = 26] = \"StrongEmphasis\";\n    Type[Type[\"Link\"] = 27] = \"Link\";\n    Type[Type[\"Image\"] = 28] = \"Image\";\n    Type[Type[\"InlineCode\"] = 29] = \"InlineCode\";\n    Type[Type[\"HTMLTag\"] = 30] = \"HTMLTag\";\n    Type[Type[\"Comment\"] = 31] = \"Comment\";\n    Type[Type[\"ProcessingInstruction\"] = 32] = \"ProcessingInstruction\";\n    Type[Type[\"Autolink\"] = 33] = \"Autolink\";\n    // Smaller tokens\n    Type[Type[\"HeaderMark\"] = 34] = \"HeaderMark\";\n    Type[Type[\"QuoteMark\"] = 35] = \"QuoteMark\";\n    Type[Type[\"ListMark\"] = 36] = \"ListMark\";\n    Type[Type[\"LinkMark\"] = 37] = \"LinkMark\";\n    Type[Type[\"EmphasisMark\"] = 38] = \"EmphasisMark\";\n    Type[Type[\"CodeMark\"] = 39] = \"CodeMark\";\n    Type[Type[\"CodeText\"] = 40] = \"CodeText\";\n    Type[Type[\"CodeInfo\"] = 41] = \"CodeInfo\";\n    Type[Type[\"LinkTitle\"] = 42] = \"LinkTitle\";\n    Type[Type[\"LinkLabel\"] = 43] = \"LinkLabel\";\n    Type[Type[\"URL\"] = 44] = \"URL\";\n})(Type || (Type = {}));\n/**\nData structure used to accumulate a block's content during [leaf\nblock parsing](#BlockParser.leaf).\n*/\nclass LeafBlock {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The start position of the block.\n    */\n    start, \n    /**\n    The block's text content.\n    */\n    content) {\n        this.start = start;\n        this.content = content;\n        /**\n        @internal\n        */\n        this.marks = [];\n        /**\n        The block parsers active for this block.\n        */\n        this.parsers = [];\n    }\n}\n/**\nData structure used during block-level per-line parsing.\n*/\nclass Line {\n    constructor() {\n        /**\n        The line's full text.\n        */\n        this.text = \"\";\n        /**\n        The base indent provided by the composite contexts (that have\n        been handled so far).\n        */\n        this.baseIndent = 0;\n        /**\n        The string position corresponding to the base indent.\n        */\n        this.basePos = 0;\n        /**\n        The number of contexts handled @internal\n        */\n        this.depth = 0;\n        /**\n        Any markers (i.e. block quote markers) parsed for the contexts. @internal\n        */\n        this.markers = [];\n        /**\n        The position of the next non-whitespace character beyond any\n        list, blockquote, or other composite block markers.\n        */\n        this.pos = 0;\n        /**\n        The column of the next non-whitespace character.\n        */\n        this.indent = 0;\n        /**\n        The character code of the character after `pos`.\n        */\n        this.next = -1;\n    }\n    /**\n    @internal\n    */\n    forward() {\n        if (this.basePos > this.pos)\n            this.forwardInner();\n    }\n    /**\n    @internal\n    */\n    forwardInner() {\n        let newPos = this.skipSpace(this.basePos);\n        this.indent = this.countIndent(newPos, this.pos, this.indent);\n        this.pos = newPos;\n        this.next = newPos == this.text.length ? -1 : this.text.charCodeAt(newPos);\n    }\n    /**\n    Skip whitespace after the given position, return the position of\n    the next non-space character or the end of the line if there's\n    only space after `from`.\n    */\n    skipSpace(from) { return skipSpace(this.text, from); }\n    /**\n    @internal\n    */\n    reset(text) {\n        this.text = text;\n        this.baseIndent = this.basePos = this.pos = this.indent = 0;\n        this.forwardInner();\n        this.depth = 1;\n        while (this.markers.length)\n            this.markers.pop();\n    }\n    /**\n    Move the line's base position forward to the given position.\n    This should only be called by composite [block\n    parsers](#BlockParser.parse) or [markup skipping\n    functions](#NodeSpec.composite).\n    */\n    moveBase(to) {\n        this.basePos = to;\n        this.baseIndent = this.countIndent(to, this.pos, this.indent);\n    }\n    /**\n    Move the line's base position forward to the given _column_.\n    */\n    moveBaseColumn(indent) {\n        this.baseIndent = indent;\n        this.basePos = this.findColumn(indent);\n    }\n    /**\n    Store a composite-block-level marker. Should be called from\n    [markup skipping functions](#NodeSpec.composite) when they\n    consume any non-whitespace characters.\n    */\n    addMarker(elt) {\n        this.markers.push(elt);\n    }\n    /**\n    Find the column position at `to`, optionally starting at a given\n    position and column.\n    */\n    countIndent(to, from = 0, indent = 0) {\n        for (let i = from; i < to; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return indent;\n    }\n    /**\n    Find the position corresponding to the given column.\n    */\n    findColumn(goal) {\n        let i = 0;\n        for (let indent = 0; i < this.text.length && indent < goal; i++)\n            indent += this.text.charCodeAt(i) == 9 ? 4 - indent % 4 : 1;\n        return i;\n    }\n    /**\n    @internal\n    */\n    scrub() {\n        if (!this.baseIndent)\n            return this.text;\n        let result = \"\";\n        for (let i = 0; i < this.basePos; i++)\n            result += \" \";\n        return result + this.text.slice(this.basePos);\n    }\n}\nfunction skipForList(bl, cx, line) {\n    if (line.pos == line.text.length ||\n        (bl != cx.block && line.indent >= cx.stack[line.depth + 1].value + line.baseIndent))\n        return true;\n    if (line.indent >= line.baseIndent + 4)\n        return false;\n    let size = (bl.type == Type.OrderedList ? isOrderedList : isBulletList)(line, cx, false);\n    return size > 0 &&\n        (bl.type != Type.BulletList || isHorizontalRule(line, cx, false) < 0) &&\n        line.text.charCodeAt(line.pos + size - 1) == bl.value;\n}\nconst DefaultSkipMarkup = {\n    [Type.Blockquote](bl, cx, line) {\n        if (line.next != 62 /* '>' */)\n            return false;\n        line.markers.push(elt(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1));\n        line.moveBase(line.pos + (space(line.text.charCodeAt(line.pos + 1)) ? 2 : 1));\n        bl.end = cx.lineStart + line.text.length;\n        return true;\n    },\n    [Type.ListItem](bl, _cx, line) {\n        if (line.indent < line.baseIndent + bl.value && line.next > -1)\n            return false;\n        line.moveBaseColumn(line.baseIndent + bl.value);\n        return true;\n    },\n    [Type.OrderedList]: skipForList,\n    [Type.BulletList]: skipForList,\n    [Type.Document]() { return true; }\n};\nfunction space(ch) { return ch == 32 || ch == 9 || ch == 10 || ch == 13; }\nfunction skipSpace(line, i = 0) {\n    while (i < line.length && space(line.charCodeAt(i)))\n        i++;\n    return i;\n}\nfunction skipSpaceBack(line, i, to) {\n    while (i > to && space(line.charCodeAt(i - 1)))\n        i--;\n    return i;\n}\nfunction isFencedCode(line) {\n    if (line.next != 96 && line.next != 126 /* '`~' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    if (pos < line.pos + 3)\n        return -1;\n    if (line.next == 96)\n        for (let i = pos; i < line.text.length; i++)\n            if (line.text.charCodeAt(i) == 96)\n                return -1;\n    return pos;\n}\nfunction isBlockquote(line) {\n    return line.next != 62 /* '>' */ ? -1 : line.text.charCodeAt(line.pos + 1) == 32 ? 2 : 1;\n}\nfunction isHorizontalRule(line, cx, breaking) {\n    if (line.next != 42 && line.next != 45 && line.next != 95 /* '_-*' */)\n        return -1;\n    let count = 1;\n    for (let pos = line.pos + 1; pos < line.text.length; pos++) {\n        let ch = line.text.charCodeAt(pos);\n        if (ch == line.next)\n            count++;\n        else if (!space(ch))\n            return -1;\n    }\n    // Setext headers take precedence\n    if (breaking && line.next == 45 && isSetextUnderline(line) > -1 && line.depth == cx.stack.length &&\n        cx.parser.leafBlockParsers.indexOf(DefaultLeafBlocks.SetextHeading) > -1)\n        return -1;\n    return count < 3 ? -1 : 1;\n}\nfunction inList(cx, type) {\n    for (let i = cx.stack.length - 1; i >= 0; i--)\n        if (cx.stack[i].type == type)\n            return true;\n    return false;\n}\nfunction isBulletList(line, cx, breaking) {\n    return (line.next == 45 || line.next == 43 || line.next == 42 /* '-+*' */) &&\n        (line.pos == line.text.length - 1 || space(line.text.charCodeAt(line.pos + 1))) &&\n        (!breaking || inList(cx, Type.BulletList) || line.skipSpace(line.pos + 2) < line.text.length) ? 1 : -1;\n}\nfunction isOrderedList(line, cx, breaking) {\n    let pos = line.pos, next = line.next;\n    for (;;) {\n        if (next >= 48 && next <= 57 /* '0-9' */)\n            pos++;\n        else\n            break;\n        if (pos == line.text.length)\n            return -1;\n        next = line.text.charCodeAt(pos);\n    }\n    if (pos == line.pos || pos > line.pos + 9 ||\n        (next != 46 && next != 41 /* '.)' */) ||\n        (pos < line.text.length - 1 && !space(line.text.charCodeAt(pos + 1))) ||\n        breaking && !inList(cx, Type.OrderedList) &&\n            (line.skipSpace(pos + 1) == line.text.length || pos > line.pos + 1 || line.next != 49 /* '1' */))\n        return -1;\n    return pos + 1 - line.pos;\n}\nfunction isAtxHeading(line) {\n    if (line.next != 35 /* '#' */)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == 35)\n        pos++;\n    if (pos < line.text.length && line.text.charCodeAt(pos) != 32)\n        return -1;\n    let size = pos - line.pos;\n    return size > 6 ? -1 : size;\n}\nfunction isSetextUnderline(line) {\n    if (line.next != 45 && line.next != 61 /* '-=' */ || line.indent >= line.baseIndent + 4)\n        return -1;\n    let pos = line.pos + 1;\n    while (pos < line.text.length && line.text.charCodeAt(pos) == line.next)\n        pos++;\n    let end = pos;\n    while (pos < line.text.length && space(line.text.charCodeAt(pos)))\n        pos++;\n    return pos == line.text.length ? end : -1;\n}\nconst EmptyLine = /^[ \\t]*$/, CommentEnd = /-->/, ProcessingEnd = /\\?>/;\nconst HTMLBlockStyle = [\n    [/^<(?:script|pre|style)(?:\\s|>|$)/i, /<\\/(?:script|pre|style)>/i],\n    [/^\\s*<!--/, CommentEnd],\n    [/^\\s*<\\?/, ProcessingEnd],\n    [/^\\s*<![A-Z]/, />/],\n    [/^\\s*<!\\[CDATA\\[/, /\\]\\]>/],\n    [/^\\s*<\\/?(?:address|article|aside|base|basefont|blockquote|body|caption|center|col|colgroup|dd|details|dialog|dir|div|dl|dt|fieldset|figcaption|figure|footer|form|frame|frameset|h1|h2|h3|h4|h5|h6|head|header|hr|html|iframe|legend|li|link|main|menu|menuitem|nav|noframes|ol|optgroup|option|p|param|section|source|summary|table|tbody|td|tfoot|th|thead|title|tr|track|ul)(?:\\s|\\/?>|$)/i, EmptyLine],\n    [/^\\s*(?:<\\/[a-z][\\w-]*\\s*>|<[a-z][\\w-]*(\\s+[a-z:_][\\w-.]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*>)\\s*$/i, EmptyLine]\n];\nfunction isHTMLBlock(line, _cx, breaking) {\n    if (line.next != 60 /* '<' */)\n        return -1;\n    let rest = line.text.slice(line.pos);\n    for (let i = 0, e = HTMLBlockStyle.length - (breaking ? 1 : 0); i < e; i++)\n        if (HTMLBlockStyle[i][0].test(rest))\n            return i;\n    return -1;\n}\nfunction getListIndent(line, pos) {\n    let indentAfter = line.countIndent(pos, line.pos, line.indent);\n    let indented = line.countIndent(line.skipSpace(pos), pos, indentAfter);\n    return indented >= indentAfter + 5 ? indentAfter + 1 : indented;\n}\nfunction addCodeText(marks, from, to) {\n    let last = marks.length - 1;\n    if (last >= 0 && marks[last].to == from && marks[last].type == Type.CodeText)\n        marks[last].to = to;\n    else\n        marks.push(elt(Type.CodeText, from, to));\n}\n// Rules for parsing blocks. A return value of false means the rule\n// doesn't apply here, true means it does. When true is returned and\n// `p.line` has been updated, the rule is assumed to have consumed a\n// leaf block. Otherwise, it is assumed to have opened a context.\nconst DefaultBlockParsers = {\n    LinkReference: undefined,\n    IndentedCode(cx, line) {\n        let base = line.baseIndent + 4;\n        if (line.indent < base)\n            return false;\n        let start = line.findColumn(base);\n        let from = cx.lineStart + start, to = cx.lineStart + line.text.length;\n        let marks = [], pendingMarks = [];\n        addCodeText(marks, from, to);\n        while (cx.nextLine() && line.depth >= cx.stack.length) {\n            if (line.pos == line.text.length) { // Empty\n                addCodeText(pendingMarks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    pendingMarks.push(m);\n            }\n            else if (line.indent < base) {\n                break;\n            }\n            else {\n                if (pendingMarks.length) {\n                    for (let m of pendingMarks) {\n                        if (m.type == Type.CodeText)\n                            addCodeText(marks, m.from, m.to);\n                        else\n                            marks.push(m);\n                    }\n                    pendingMarks = [];\n                }\n                addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                to = cx.lineStart + line.text.length;\n                let codeStart = cx.lineStart + line.findColumn(line.baseIndent + 4);\n                if (codeStart < to)\n                    addCodeText(marks, codeStart, to);\n            }\n        }\n        if (pendingMarks.length) {\n            pendingMarks = pendingMarks.filter(m => m.type != Type.CodeText);\n            if (pendingMarks.length)\n                line.markers = pendingMarks.concat(line.markers);\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(Type.CodeBlock, to - from), from);\n        return true;\n    },\n    FencedCode(cx, line) {\n        let fenceEnd = isFencedCode(line);\n        if (fenceEnd < 0)\n            return false;\n        let from = cx.lineStart + line.pos, ch = line.next, len = fenceEnd - line.pos;\n        let infoFrom = line.skipSpace(fenceEnd), infoTo = skipSpaceBack(line.text, line.text.length, infoFrom);\n        let marks = [elt(Type.CodeMark, from, from + len)];\n        if (infoFrom < infoTo)\n            marks.push(elt(Type.CodeInfo, cx.lineStart + infoFrom, cx.lineStart + infoTo));\n        for (let first = true; cx.nextLine() && line.depth >= cx.stack.length; first = false) {\n            let i = line.pos;\n            if (line.indent - line.baseIndent < 4)\n                while (i < line.text.length && line.text.charCodeAt(i) == ch)\n                    i++;\n            if (i - line.pos >= len && line.skipSpace(i) == line.text.length) {\n                for (let m of line.markers)\n                    marks.push(m);\n                marks.push(elt(Type.CodeMark, cx.lineStart + line.pos, cx.lineStart + i));\n                cx.nextLine();\n                break;\n            }\n            else {\n                if (!first)\n                    addCodeText(marks, cx.lineStart - 1, cx.lineStart);\n                for (let m of line.markers)\n                    marks.push(m);\n                let textStart = cx.lineStart + line.basePos, textEnd = cx.lineStart + line.text.length;\n                if (textStart < textEnd)\n                    addCodeText(marks, textStart, textEnd);\n            }\n        }\n        cx.addNode(cx.buffer.writeElements(marks, -from)\n            .finish(Type.FencedCode, cx.prevLineEnd() - from), from);\n        return true;\n    },\n    Blockquote(cx, line) {\n        let size = isBlockquote(line);\n        if (size < 0)\n            return false;\n        cx.startContext(Type.Blockquote, line.pos);\n        cx.addNode(Type.QuoteMark, cx.lineStart + line.pos, cx.lineStart + line.pos + 1);\n        line.moveBase(line.pos + size);\n        return null;\n    },\n    HorizontalRule(cx, line) {\n        if (isHorizontalRule(line, cx, false) < 0)\n            return false;\n        let from = cx.lineStart + line.pos;\n        cx.nextLine();\n        cx.addNode(Type.HorizontalRule, from);\n        return true;\n    },\n    BulletList(cx, line) {\n        let size = isBulletList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.BulletList)\n            cx.startContext(Type.BulletList, line.basePos, line.next);\n        let newBase = getListIndent(line, line.pos + 1);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    OrderedList(cx, line) {\n        let size = isOrderedList(line, cx, false);\n        if (size < 0)\n            return false;\n        if (cx.block.type != Type.OrderedList)\n            cx.startContext(Type.OrderedList, line.basePos, line.text.charCodeAt(line.pos + size - 1));\n        let newBase = getListIndent(line, line.pos + size);\n        cx.startContext(Type.ListItem, line.basePos, newBase - line.baseIndent);\n        cx.addNode(Type.ListMark, cx.lineStart + line.pos, cx.lineStart + line.pos + size);\n        line.moveBaseColumn(newBase);\n        return null;\n    },\n    ATXHeading(cx, line) {\n        let size = isAtxHeading(line);\n        if (size < 0)\n            return false;\n        let off = line.pos, from = cx.lineStart + off;\n        let endOfSpace = skipSpaceBack(line.text, line.text.length, off), after = endOfSpace;\n        while (after > off && line.text.charCodeAt(after - 1) == line.next)\n            after--;\n        if (after == endOfSpace || after == off || !space(line.text.charCodeAt(after - 1)))\n            after = line.text.length;\n        let buf = cx.buffer\n            .write(Type.HeaderMark, 0, size)\n            .writeElements(cx.parser.parseInline(line.text.slice(off + size + 1, after), from + size + 1), -from);\n        if (after < line.text.length)\n            buf.write(Type.HeaderMark, after - off, endOfSpace - off);\n        let node = buf.finish(Type.ATXHeading1 - 1 + size, line.text.length - off);\n        cx.nextLine();\n        cx.addNode(node, from);\n        return true;\n    },\n    HTMLBlock(cx, line) {\n        let type = isHTMLBlock(line, cx, false);\n        if (type < 0)\n            return false;\n        let from = cx.lineStart + line.pos, end = HTMLBlockStyle[type][1];\n        let marks = [], trailing = end != EmptyLine;\n        while (!end.test(line.text) && cx.nextLine()) {\n            if (line.depth < cx.stack.length) {\n                trailing = false;\n                break;\n            }\n            for (let m of line.markers)\n                marks.push(m);\n        }\n        if (trailing)\n            cx.nextLine();\n        let nodeType = end == CommentEnd ? Type.CommentBlock : end == ProcessingEnd ? Type.ProcessingInstructionBlock : Type.HTMLBlock;\n        let to = cx.prevLineEnd();\n        cx.addNode(cx.buffer.writeElements(marks, -from).finish(nodeType, to - from), from);\n        return true;\n    },\n    SetextHeading: undefined // Specifies relative precedence for block-continue function\n};\n// This implements a state machine that incrementally parses link references. At each\n// next line, it looks ahead to see if the line continues the reference or not. If it\n// doesn't and a valid link is available ending before that line, it finishes that.\n// Similarly, on `finish` (when the leaf is terminated by external circumstances), it\n// creates a link reference if there's a valid reference up to the current point.\nclass LinkReferenceParser {\n    constructor(leaf) {\n        this.stage = 0 /* RefStage.Start */;\n        this.elts = [];\n        this.pos = 0;\n        this.start = leaf.start;\n        this.advance(leaf.content);\n    }\n    nextLine(cx, line, leaf) {\n        if (this.stage == -1 /* RefStage.Failed */)\n            return false;\n        let content = leaf.content + \"\\n\" + line.scrub();\n        let finish = this.advance(content);\n        if (finish > -1 && finish < content.length)\n            return this.complete(cx, leaf, finish);\n        return false;\n    }\n    finish(cx, leaf) {\n        if ((this.stage == 2 /* RefStage.Link */ || this.stage == 3 /* RefStage.Title */) && skipSpace(leaf.content, this.pos) == leaf.content.length)\n            return this.complete(cx, leaf, leaf.content.length);\n        return false;\n    }\n    complete(cx, leaf, len) {\n        cx.addLeafElement(leaf, elt(Type.LinkReference, this.start, this.start + len, this.elts));\n        return true;\n    }\n    nextStage(elt) {\n        if (elt) {\n            this.pos = elt.to - this.start;\n            this.elts.push(elt);\n            this.stage++;\n            return true;\n        }\n        if (elt === false)\n            this.stage = -1 /* RefStage.Failed */;\n        return false;\n    }\n    advance(content) {\n        for (;;) {\n            if (this.stage == -1 /* RefStage.Failed */) {\n                return -1;\n            }\n            else if (this.stage == 0 /* RefStage.Start */) {\n                if (!this.nextStage(parseLinkLabel(content, this.pos, this.start, true)))\n                    return -1;\n                if (content.charCodeAt(this.pos) != 58 /* ':' */)\n                    return this.stage = -1 /* RefStage.Failed */;\n                this.elts.push(elt(Type.LinkMark, this.pos + this.start, this.pos + this.start + 1));\n                this.pos++;\n            }\n            else if (this.stage == 1 /* RefStage.Label */) {\n                if (!this.nextStage(parseURL(content, skipSpace(content, this.pos), this.start)))\n                    return -1;\n            }\n            else if (this.stage == 2 /* RefStage.Link */) {\n                let skip = skipSpace(content, this.pos), end = 0;\n                if (skip > this.pos) {\n                    let title = parseLinkTitle(content, skip, this.start);\n                    if (title) {\n                        let titleEnd = lineEnd(content, title.to - this.start);\n                        if (titleEnd > 0) {\n                            this.nextStage(title);\n                            end = titleEnd;\n                        }\n                    }\n                }\n                if (!end)\n                    end = lineEnd(content, this.pos);\n                return end > 0 && end < content.length ? end : -1;\n            }\n            else { // RefStage.Title\n                return lineEnd(content, this.pos);\n            }\n        }\n    }\n}\nfunction lineEnd(text, pos) {\n    for (; pos < text.length; pos++) {\n        let next = text.charCodeAt(pos);\n        if (next == 10)\n            break;\n        if (!space(next))\n            return -1;\n    }\n    return pos;\n}\nclass SetextHeadingParser {\n    nextLine(cx, line, leaf) {\n        let underline = line.depth < cx.stack.length ? -1 : isSetextUnderline(line);\n        let next = line.next;\n        if (underline < 0)\n            return false;\n        let underlineMark = elt(Type.HeaderMark, cx.lineStart + line.pos, cx.lineStart + underline);\n        cx.nextLine();\n        cx.addLeafElement(leaf, elt(next == 61 ? Type.SetextHeading1 : Type.SetextHeading2, leaf.start, cx.prevLineEnd(), [\n            ...cx.parser.parseInline(leaf.content, leaf.start),\n            underlineMark\n        ]));\n        return true;\n    }\n    finish() {\n        return false;\n    }\n}\nconst DefaultLeafBlocks = {\n    LinkReference(_, leaf) { return leaf.content.charCodeAt(0) == 91 /* '[' */ ? new LinkReferenceParser(leaf) : null; },\n    SetextHeading() { return new SetextHeadingParser; }\n};\nconst DefaultEndLeaf = [\n    (_, line) => isAtxHeading(line) >= 0,\n    (_, line) => isFencedCode(line) >= 0,\n    (_, line) => isBlockquote(line) >= 0,\n    (p, line) => isBulletList(line, p, true) >= 0,\n    (p, line) => isOrderedList(line, p, true) >= 0,\n    (p, line) => isHorizontalRule(line, p, true) >= 0,\n    (p, line) => isHTMLBlock(line, p, true) >= 0\n];\nconst scanLineResult = { text: \"\", end: 0 };\n/**\nBlock-level parsing functions get access to this context object.\n*/\nclass BlockContext {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser configuration used.\n    */\n    parser, \n    /**\n    @internal\n    */\n    input, fragments, \n    /**\n    @internal\n    */\n    ranges) {\n        this.parser = parser;\n        this.input = input;\n        this.ranges = ranges;\n        this.line = new Line();\n        this.atEnd = false;\n        /**\n        For reused nodes on gaps, we can't directly put the original\n        node into the tree, since that may be bigger than its parent.\n        When this happens, we create a dummy tree that is replaced by\n        the proper node in `injectGaps` @internal\n        */\n        this.reusePlaceholders = new Map;\n        this.stoppedAt = null;\n        /**\n        The range index that absoluteLineStart points into @internal\n        */\n        this.rangeI = 0;\n        this.to = ranges[ranges.length - 1].to;\n        this.lineStart = this.absoluteLineStart = this.absoluteLineEnd = ranges[0].from;\n        this.block = CompositeBlock.create(Type.Document, 0, this.lineStart, 0, 0);\n        this.stack = [this.block];\n        this.fragments = fragments.length ? new FragmentCursor(fragments, input) : null;\n        this.readLine();\n    }\n    get parsedPos() {\n        return this.absoluteLineStart;\n    }\n    advance() {\n        if (this.stoppedAt != null && this.absoluteLineStart > this.stoppedAt)\n            return this.finish();\n        let { line } = this;\n        for (;;) {\n            for (let markI = 0;;) {\n                let next = line.depth < this.stack.length ? this.stack[this.stack.length - 1] : null;\n                while (markI < line.markers.length && (!next || line.markers[markI].from < next.end)) {\n                    let mark = line.markers[markI++];\n                    this.addNode(mark.type, mark.from, mark.to);\n                }\n                if (!next)\n                    break;\n                this.finishContext();\n            }\n            if (line.pos < line.text.length)\n                break;\n            // Empty line\n            if (!this.nextLine())\n                return this.finish();\n        }\n        if (this.fragments && this.reuseFragment(line.basePos))\n            return null;\n        start: for (;;) {\n            for (let type of this.parser.blockParsers)\n                if (type) {\n                    let result = type(this, line);\n                    if (result != false) {\n                        if (result == true)\n                            return null;\n                        line.forward();\n                        continue start;\n                    }\n                }\n            break;\n        }\n        let leaf = new LeafBlock(this.lineStart + line.pos, line.text.slice(line.pos));\n        for (let parse of this.parser.leafBlockParsers)\n            if (parse) {\n                let parser = parse(this, leaf);\n                if (parser)\n                    leaf.parsers.push(parser);\n            }\n        lines: while (this.nextLine()) {\n            if (line.pos == line.text.length)\n                break;\n            if (line.indent < line.baseIndent + 4) {\n                for (let stop of this.parser.endLeafBlock)\n                    if (stop(this, line, leaf))\n                        break lines;\n            }\n            for (let parser of leaf.parsers)\n                if (parser.nextLine(this, line, leaf))\n                    return null;\n            leaf.content += \"\\n\" + line.scrub();\n            for (let m of line.markers)\n                leaf.marks.push(m);\n        }\n        this.finishLeaf(leaf);\n        return null;\n    }\n    stopAt(pos) {\n        if (this.stoppedAt != null && this.stoppedAt < pos)\n            throw new RangeError(\"Can't move stoppedAt forward\");\n        this.stoppedAt = pos;\n    }\n    reuseFragment(start) {\n        if (!this.fragments.moveTo(this.absoluteLineStart + start, this.absoluteLineStart) ||\n            !this.fragments.matches(this.block.hash))\n            return false;\n        let taken = this.fragments.takeNodes(this);\n        if (!taken)\n            return false;\n        this.absoluteLineStart += taken;\n        this.lineStart = toRelative(this.absoluteLineStart, this.ranges);\n        this.moveRangeI();\n        if (this.absoluteLineStart < this.to) {\n            this.lineStart++;\n            this.absoluteLineStart++;\n            this.readLine();\n        }\n        else {\n            this.atEnd = true;\n            this.readLine();\n        }\n        return true;\n    }\n    /**\n    The number of parent blocks surrounding the current block.\n    */\n    get depth() {\n        return this.stack.length;\n    }\n    /**\n    Get the type of the parent block at the given depth. When no\n    depth is passed, return the type of the innermost parent.\n    */\n    parentType(depth = this.depth - 1) {\n        return this.parser.nodeSet.types[this.stack[depth].type];\n    }\n    /**\n    Move to the next input line. This should only be called by\n    (non-composite) [block parsers](#BlockParser.parse) that consume\n    the line directly, or leaf block parser\n    [`nextLine`](#LeafBlockParser.nextLine) methods when they\n    consume the current line (and return true).\n    */\n    nextLine() {\n        this.lineStart += this.line.text.length;\n        if (this.absoluteLineEnd >= this.to) {\n            this.absoluteLineStart = this.absoluteLineEnd;\n            this.atEnd = true;\n            this.readLine();\n            return false;\n        }\n        else {\n            this.lineStart++;\n            this.absoluteLineStart = this.absoluteLineEnd + 1;\n            this.moveRangeI();\n            this.readLine();\n            return true;\n        }\n    }\n    /**\n    Retrieve the text of the line after the current one, without\n    actually moving the context's current line forward.\n    */\n    peekLine() {\n        return this.scanLine(this.absoluteLineEnd + 1).text;\n    }\n    moveRangeI() {\n        while (this.rangeI < this.ranges.length - 1 && this.absoluteLineStart >= this.ranges[this.rangeI].to) {\n            this.rangeI++;\n            this.absoluteLineStart = Math.max(this.absoluteLineStart, this.ranges[this.rangeI].from);\n        }\n    }\n    /**\n    @internal\n    Collect the text for the next line.\n    */\n    scanLine(start) {\n        let r = scanLineResult;\n        r.end = start;\n        if (start >= this.to) {\n            r.text = \"\";\n        }\n        else {\n            r.text = this.lineChunkAt(start);\n            r.end += r.text.length;\n            if (this.ranges.length > 1) {\n                let textOffset = this.absoluteLineStart, rangeI = this.rangeI;\n                while (this.ranges[rangeI].to < r.end) {\n                    rangeI++;\n                    let nextFrom = this.ranges[rangeI].from;\n                    let after = this.lineChunkAt(nextFrom);\n                    r.end = nextFrom + after.length;\n                    r.text = r.text.slice(0, this.ranges[rangeI - 1].to - textOffset) + after;\n                    textOffset = r.end - r.text.length;\n                }\n            }\n        }\n        return r;\n    }\n    /**\n    @internal\n    Populate this.line with the content of the next line. Skip\n    leading characters covered by composite blocks.\n    */\n    readLine() {\n        let { line } = this, { text, end } = this.scanLine(this.absoluteLineStart);\n        this.absoluteLineEnd = end;\n        line.reset(text);\n        for (; line.depth < this.stack.length; line.depth++) {\n            let cx = this.stack[line.depth], handler = this.parser.skipContextMarkup[cx.type];\n            if (!handler)\n                throw new Error(\"Unhandled block context \" + Type[cx.type]);\n            if (!handler(cx, this, line))\n                break;\n            line.forward();\n        }\n    }\n    lineChunkAt(pos) {\n        let next = this.input.chunk(pos), text;\n        if (!this.input.lineChunks) {\n            let eol = next.indexOf(\"\\n\");\n            text = eol < 0 ? next : next.slice(0, eol);\n        }\n        else {\n            text = next == \"\\n\" ? \"\" : next;\n        }\n        return pos + text.length > this.to ? text.slice(0, this.to - pos) : text;\n    }\n    /**\n    The end position of the previous line.\n    */\n    prevLineEnd() { return this.atEnd ? this.lineStart : this.lineStart - 1; }\n    /**\n    @internal\n    */\n    startContext(type, start, value = 0) {\n        this.block = CompositeBlock.create(type, value, this.lineStart + start, this.block.hash, this.lineStart + this.line.text.length);\n        this.stack.push(this.block);\n    }\n    /**\n    Start a composite block. Should only be called from [block\n    parser functions](#BlockParser.parse) that return null.\n    */\n    startComposite(type, start, value = 0) {\n        this.startContext(this.parser.getNodeType(type), start, value);\n    }\n    /**\n    @internal\n    */\n    addNode(block, from, to) {\n        if (typeof block == \"number\")\n            block = new Tree(this.parser.nodeSet.types[block], none, none, (to !== null && to !== void 0 ? to : this.prevLineEnd()) - from);\n        this.block.addChild(block, from - this.block.from);\n    }\n    /**\n    Add a block element. Can be called by [block\n    parsers](#BlockParser.parse).\n    */\n    addElement(elt) {\n        this.block.addChild(elt.toTree(this.parser.nodeSet), elt.from - this.block.from);\n    }\n    /**\n    Add a block element from a [leaf parser](#LeafBlockParser). This\n    makes sure any extra composite block markup (such as blockquote\n    markers) inside the block are also added to the syntax tree.\n    */\n    addLeafElement(leaf, elt) {\n        this.addNode(this.buffer\n            .writeElements(injectMarks(elt.children, leaf.marks), -elt.from)\n            .finish(elt.type, elt.to - elt.from), elt.from);\n    }\n    /**\n    @internal\n    */\n    finishContext() {\n        let cx = this.stack.pop();\n        let top = this.stack[this.stack.length - 1];\n        top.addChild(cx.toTree(this.parser.nodeSet), cx.from - top.from);\n        this.block = top;\n    }\n    finish() {\n        while (this.stack.length > 1)\n            this.finishContext();\n        return this.addGaps(this.block.toTree(this.parser.nodeSet, this.lineStart));\n    }\n    addGaps(tree) {\n        return this.ranges.length > 1 ?\n            injectGaps(this.ranges, 0, tree.topNode, this.ranges[0].from, this.reusePlaceholders) : tree;\n    }\n    /**\n    @internal\n    */\n    finishLeaf(leaf) {\n        for (let parser of leaf.parsers)\n            if (parser.finish(this, leaf))\n                return;\n        let inline = injectMarks(this.parser.parseInline(leaf.content, leaf.start), leaf.marks);\n        this.addNode(this.buffer\n            .writeElements(inline, -leaf.start)\n            .finish(Type.Paragraph, leaf.content.length), leaf.start);\n    }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n    /**\n    @internal\n    */\n    get buffer() { return new Buffer(this.parser.nodeSet); }\n}\nfunction injectGaps(ranges, rangeI, tree, offset, dummies) {\n    let rangeEnd = ranges[rangeI].to;\n    let children = [], positions = [], start = tree.from + offset;\n    function movePastNext(upto, inclusive) {\n        while (inclusive ? upto >= rangeEnd : upto > rangeEnd) {\n            let size = ranges[rangeI + 1].from - rangeEnd;\n            offset += size;\n            upto += size;\n            rangeI++;\n            rangeEnd = ranges[rangeI].to;\n        }\n    }\n    for (let ch = tree.firstChild; ch; ch = ch.nextSibling) {\n        movePastNext(ch.from + offset, true);\n        let from = ch.from + offset, node, reuse = dummies.get(ch.tree);\n        if (reuse) {\n            node = reuse;\n        }\n        else if (ch.to + offset > rangeEnd) {\n            node = injectGaps(ranges, rangeI, ch, offset, dummies);\n            movePastNext(ch.to + offset, false);\n        }\n        else {\n            node = ch.toTree();\n        }\n        children.push(node);\n        positions.push(from - start);\n    }\n    movePastNext(tree.to + offset, false);\n    return new Tree(tree.type, children, positions, tree.to + offset - start, tree.tree ? tree.tree.propValues : undefined);\n}\n/**\nA Markdown parser configuration.\n*/\nclass MarkdownParser extends Parser {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser's syntax [node\n    types](https://lezer.codemirror.net/docs/ref/#common.NodeSet).\n    */\n    nodeSet, \n    /**\n    @internal\n    */\n    blockParsers, \n    /**\n    @internal\n    */\n    leafBlockParsers, \n    /**\n    @internal\n    */\n    blockNames, \n    /**\n    @internal\n    */\n    endLeafBlock, \n    /**\n    @internal\n    */\n    skipContextMarkup, \n    /**\n    @internal\n    */\n    inlineParsers, \n    /**\n    @internal\n    */\n    inlineNames, \n    /**\n    @internal\n    */\n    wrappers) {\n        super();\n        this.nodeSet = nodeSet;\n        this.blockParsers = blockParsers;\n        this.leafBlockParsers = leafBlockParsers;\n        this.blockNames = blockNames;\n        this.endLeafBlock = endLeafBlock;\n        this.skipContextMarkup = skipContextMarkup;\n        this.inlineParsers = inlineParsers;\n        this.inlineNames = inlineNames;\n        this.wrappers = wrappers;\n        /**\n        @internal\n        */\n        this.nodeTypes = Object.create(null);\n        for (let t of nodeSet.types)\n            this.nodeTypes[t.name] = t.id;\n    }\n    createParse(input, fragments, ranges) {\n        let parse = new BlockContext(this, input, fragments, ranges);\n        for (let w of this.wrappers)\n            parse = w(parse, input, fragments, ranges);\n        return parse;\n    }\n    /**\n    Reconfigure the parser.\n    */\n    configure(spec) {\n        let config = resolveConfig(spec);\n        if (!config)\n            return this;\n        let { nodeSet, skipContextMarkup } = this;\n        let blockParsers = this.blockParsers.slice(), leafBlockParsers = this.leafBlockParsers.slice(), blockNames = this.blockNames.slice(), inlineParsers = this.inlineParsers.slice(), inlineNames = this.inlineNames.slice(), endLeafBlock = this.endLeafBlock.slice(), wrappers = this.wrappers;\n        if (nonEmpty(config.defineNodes)) {\n            skipContextMarkup = Object.assign({}, skipContextMarkup);\n            let nodeTypes = nodeSet.types.slice(), styles;\n            for (let s of config.defineNodes) {\n                let { name, block, composite, style } = typeof s == \"string\" ? { name: s } : s;\n                if (nodeTypes.some(t => t.name == name))\n                    continue;\n                if (composite)\n                    skipContextMarkup[nodeTypes.length] =\n                        (bl, cx, line) => composite(cx, line, bl.value);\n                let id = nodeTypes.length;\n                let group = composite ? [\"Block\", \"BlockContext\"] : !block ? undefined\n                    : id >= Type.ATXHeading1 && id <= Type.SetextHeading2 ? [\"Block\", \"LeafBlock\", \"Heading\"] : [\"Block\", \"LeafBlock\"];\n                nodeTypes.push(NodeType.define({\n                    id,\n                    name,\n                    props: group && [[NodeProp.group, group]]\n                }));\n                if (style) {\n                    if (!styles)\n                        styles = {};\n                    if (Array.isArray(style) || style instanceof Tag)\n                        styles[name] = style;\n                    else\n                        Object.assign(styles, style);\n                }\n            }\n            nodeSet = new NodeSet(nodeTypes);\n            if (styles)\n                nodeSet = nodeSet.extend(styleTags(styles));\n        }\n        if (nonEmpty(config.props))\n            nodeSet = nodeSet.extend(...config.props);\n        if (nonEmpty(config.remove)) {\n            for (let rm of config.remove) {\n                let block = this.blockNames.indexOf(rm), inline = this.inlineNames.indexOf(rm);\n                if (block > -1)\n                    blockParsers[block] = leafBlockParsers[block] = undefined;\n                if (inline > -1)\n                    inlineParsers[inline] = undefined;\n            }\n        }\n        if (nonEmpty(config.parseBlock)) {\n            for (let spec of config.parseBlock) {\n                let found = blockNames.indexOf(spec.name);\n                if (found > -1) {\n                    blockParsers[found] = spec.parse;\n                    leafBlockParsers[found] = spec.leaf;\n                }\n                else {\n                    let pos = spec.before ? findName(blockNames, spec.before)\n                        : spec.after ? findName(blockNames, spec.after) + 1 : blockNames.length - 1;\n                    blockParsers.splice(pos, 0, spec.parse);\n                    leafBlockParsers.splice(pos, 0, spec.leaf);\n                    blockNames.splice(pos, 0, spec.name);\n                }\n                if (spec.endLeaf)\n                    endLeafBlock.push(spec.endLeaf);\n            }\n        }\n        if (nonEmpty(config.parseInline)) {\n            for (let spec of config.parseInline) {\n                let found = inlineNames.indexOf(spec.name);\n                if (found > -1) {\n                    inlineParsers[found] = spec.parse;\n                }\n                else {\n                    let pos = spec.before ? findName(inlineNames, spec.before)\n                        : spec.after ? findName(inlineNames, spec.after) + 1 : inlineNames.length - 1;\n                    inlineParsers.splice(pos, 0, spec.parse);\n                    inlineNames.splice(pos, 0, spec.name);\n                }\n            }\n        }\n        if (config.wrap)\n            wrappers = wrappers.concat(config.wrap);\n        return new MarkdownParser(nodeSet, blockParsers, leafBlockParsers, blockNames, endLeafBlock, skipContextMarkup, inlineParsers, inlineNames, wrappers);\n    }\n    /**\n    @internal\n    */\n    getNodeType(name) {\n        let found = this.nodeTypes[name];\n        if (found == null)\n            throw new RangeError(`Unknown node type '${name}'`);\n        return found;\n    }\n    /**\n    Parse the given piece of inline text at the given offset,\n    returning an array of [`Element`](#Element) objects representing\n    the inline content.\n    */\n    parseInline(text, offset) {\n        let cx = new InlineContext(this, text, offset);\n        outer: for (let pos = offset; pos < cx.end;) {\n            let next = cx.char(pos);\n            for (let token of this.inlineParsers)\n                if (token) {\n                    let result = token(cx, next, pos);\n                    if (result >= 0) {\n                        pos = result;\n                        continue outer;\n                    }\n                }\n            pos++;\n        }\n        return cx.resolveMarkers(0);\n    }\n}\nfunction nonEmpty(a) {\n    return a != null && a.length > 0;\n}\nfunction resolveConfig(spec) {\n    if (!Array.isArray(spec))\n        return spec;\n    if (spec.length == 0)\n        return null;\n    let conf = resolveConfig(spec[0]);\n    if (spec.length == 1)\n        return conf;\n    let rest = resolveConfig(spec.slice(1));\n    if (!rest || !conf)\n        return conf || rest;\n    let conc = (a, b) => (a || none).concat(b || none);\n    let wrapA = conf.wrap, wrapB = rest.wrap;\n    return {\n        props: conc(conf.props, rest.props),\n        defineNodes: conc(conf.defineNodes, rest.defineNodes),\n        parseBlock: conc(conf.parseBlock, rest.parseBlock),\n        parseInline: conc(conf.parseInline, rest.parseInline),\n        remove: conc(conf.remove, rest.remove),\n        wrap: !wrapA ? wrapB : !wrapB ? wrapA :\n            (inner, input, fragments, ranges) => wrapA(wrapB(inner, input, fragments, ranges), input, fragments, ranges)\n    };\n}\nfunction findName(names, name) {\n    let found = names.indexOf(name);\n    if (found < 0)\n        throw new RangeError(`Position specified relative to unknown parser ${name}`);\n    return found;\n}\nlet nodeTypes = [NodeType.none];\nfor (let i = 1, name; name = Type[i]; i++) {\n    nodeTypes[i] = NodeType.define({\n        id: i,\n        name,\n        props: i >= Type.Escape ? [] : [[NodeProp.group, i in DefaultSkipMarkup ? [\"Block\", \"BlockContext\"] : [\"Block\", \"LeafBlock\"]]],\n        top: name == \"Document\"\n    });\n}\nconst none = [];\nclass Buffer {\n    constructor(nodeSet) {\n        this.nodeSet = nodeSet;\n        this.content = [];\n        this.nodes = [];\n    }\n    write(type, from, to, children = 0) {\n        this.content.push(type, from, to, 4 + children * 4);\n        return this;\n    }\n    writeElements(elts, offset = 0) {\n        for (let e of elts)\n            e.writeTo(this, offset);\n        return this;\n    }\n    finish(type, length) {\n        return Tree.build({\n            buffer: this.content,\n            nodeSet: this.nodeSet,\n            reused: this.nodes,\n            topID: type,\n            length\n        });\n    }\n}\n/**\nElements are used to compose syntax nodes during parsing.\n*/\nclass Element {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The node's\n    [id](https://lezer.codemirror.net/docs/ref/#common.NodeType.id).\n    */\n    type, \n    /**\n    The start of the node, as an offset from the start of the document.\n    */\n    from, \n    /**\n    The end of the node.\n    */\n    to, \n    /**\n    The node's child nodes @internal\n    */\n    children = none) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.children = children;\n    }\n    /**\n    @internal\n    */\n    writeTo(buf, offset) {\n        let startOff = buf.content.length;\n        buf.writeElements(this.children, offset);\n        buf.content.push(this.type, this.from + offset, this.to + offset, buf.content.length + 4 - startOff);\n    }\n    /**\n    @internal\n    */\n    toTree(nodeSet) {\n        return new Buffer(nodeSet).writeElements(this.children, -this.from).finish(this.type, this.to - this.from);\n    }\n}\nclass TreeElement {\n    constructor(tree, from) {\n        this.tree = tree;\n        this.from = from;\n    }\n    get to() { return this.from + this.tree.length; }\n    get type() { return this.tree.type.id; }\n    get children() { return none; }\n    writeTo(buf, offset) {\n        buf.nodes.push(this.tree);\n        buf.content.push(buf.nodes.length - 1, this.from + offset, this.to + offset, -1);\n    }\n    toTree() { return this.tree; }\n}\nfunction elt(type, from, to, children) {\n    return new Element(type, from, to, children);\n}\nconst EmphasisUnderscore = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst EmphasisAsterisk = { resolve: \"Emphasis\", mark: \"EmphasisMark\" };\nconst LinkStart = {}, ImageStart = {};\nclass InlineDelimiter {\n    constructor(type, from, to, side) {\n        this.type = type;\n        this.from = from;\n        this.to = to;\n        this.side = side;\n    }\n}\nconst Escapable = \"!\\\"#$%&'()*+,-./:;<=>?@[\\\\]^_`{|}~\";\nlet Punctuation = /[!\"#$%&'()*+,\\-.\\/:;<=>?@\\[\\\\\\]^_`{|}~\\xA1\\u2010-\\u2027]/;\ntry {\n    Punctuation = new RegExp(\"[\\\\p{S}|\\\\p{P}]\", \"u\");\n}\ncatch (_) { }\nconst DefaultInline = {\n    Escape(cx, next, start) {\n        if (next != 92 /* '\\\\' */ || start == cx.end - 1)\n            return -1;\n        let escaped = cx.char(start + 1);\n        for (let i = 0; i < Escapable.length; i++)\n            if (Escapable.charCodeAt(i) == escaped)\n                return cx.append(elt(Type.Escape, start, start + 2));\n        return -1;\n    },\n    Entity(cx, next, start) {\n        if (next != 38 /* '&' */)\n            return -1;\n        let m = /^(?:#\\d+|#x[a-f\\d]+|\\w+);/i.exec(cx.slice(start + 1, start + 31));\n        return m ? cx.append(elt(Type.Entity, start, start + 1 + m[0].length)) : -1;\n    },\n    InlineCode(cx, next, start) {\n        if (next != 96 /* '`' */ || start && cx.char(start - 1) == 96)\n            return -1;\n        let pos = start + 1;\n        while (pos < cx.end && cx.char(pos) == 96)\n            pos++;\n        let size = pos - start, curSize = 0;\n        for (; pos < cx.end; pos++) {\n            if (cx.char(pos) == 96) {\n                curSize++;\n                if (curSize == size && cx.char(pos + 1) != 96)\n                    return cx.append(elt(Type.InlineCode, start, pos + 1, [\n                        elt(Type.CodeMark, start, start + size),\n                        elt(Type.CodeMark, pos + 1 - size, pos + 1)\n                    ]));\n            }\n            else {\n                curSize = 0;\n            }\n        }\n        return -1;\n    },\n    HTMLTag(cx, next, start) {\n        if (next != 60 /* '<' */ || start == cx.end - 1)\n            return -1;\n        let after = cx.slice(start + 1, cx.end);\n        let url = /^(?:[a-z][-\\w+.]+:[^\\s>]+|[a-z\\d.!#$%&'*+/=?^_`{|}~-]+@[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?(?:\\.[a-z\\d](?:[a-z\\d-]{0,61}[a-z\\d])?)*)>/i.exec(after);\n        if (url) {\n            return cx.append(elt(Type.Autolink, start, start + 1 + url[0].length, [\n                elt(Type.LinkMark, start, start + 1),\n                // url[0] includes the closing bracket, so exclude it from this slice\n                elt(Type.URL, start + 1, start + url[0].length),\n                elt(Type.LinkMark, start + url[0].length, start + 1 + url[0].length)\n            ]));\n        }\n        let comment = /^!--[^>](?:-[^-]|[^-])*?-->/i.exec(after);\n        if (comment)\n            return cx.append(elt(Type.Comment, start, start + 1 + comment[0].length));\n        let procInst = /^\\?[^]*?\\?>/.exec(after);\n        if (procInst)\n            return cx.append(elt(Type.ProcessingInstruction, start, start + 1 + procInst[0].length));\n        let m = /^(?:![A-Z][^]*?>|!\\[CDATA\\[[^]*?\\]\\]>|\\/\\s*[a-zA-Z][\\w-]*\\s*>|\\s*[a-zA-Z][\\w-]*(\\s+[a-zA-Z:_][\\w-.:]*(?:\\s*=\\s*(?:[^\\s\"'=<>`]+|'[^']*'|\"[^\"]*\"))?)*\\s*(\\/\\s*)?>)/.exec(after);\n        if (!m)\n            return -1;\n        return cx.append(elt(Type.HTMLTag, start, start + 1 + m[0].length));\n    },\n    Emphasis(cx, next, start) {\n        if (next != 95 && next != 42)\n            return -1;\n        let pos = start + 1;\n        while (cx.char(pos) == next)\n            pos++;\n        let before = cx.slice(start - 1, start), after = cx.slice(pos, pos + 1);\n        let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n        let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n        let leftFlanking = !sAfter && (!pAfter || sBefore || pBefore);\n        let rightFlanking = !sBefore && (!pBefore || sAfter || pAfter);\n        let canOpen = leftFlanking && (next == 42 || !rightFlanking || pBefore);\n        let canClose = rightFlanking && (next == 42 || !leftFlanking || pAfter);\n        return cx.append(new InlineDelimiter(next == 95 ? EmphasisUnderscore : EmphasisAsterisk, start, pos, (canOpen ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (canClose ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\n    },\n    HardBreak(cx, next, start) {\n        if (next == 92 /* '\\\\' */ && cx.char(start + 1) == 10 /* '\\n' */)\n            return cx.append(elt(Type.HardBreak, start, start + 2));\n        if (next == 32) {\n            let pos = start + 1;\n            while (cx.char(pos) == 32)\n                pos++;\n            if (cx.char(pos) == 10 && pos >= start + 2)\n                return cx.append(elt(Type.HardBreak, start, pos + 1));\n        }\n        return -1;\n    },\n    Link(cx, next, start) {\n        return next == 91 /* '[' */ ? cx.append(new InlineDelimiter(LinkStart, start, start + 1, 1 /* Mark.Open */)) : -1;\n    },\n    Image(cx, next, start) {\n        return next == 33 /* '!' */ && cx.char(start + 1) == 91 /* '[' */\n            ? cx.append(new InlineDelimiter(ImageStart, start, start + 2, 1 /* Mark.Open */)) : -1;\n    },\n    LinkEnd(cx, next, start) {\n        if (next != 93 /* ']' */)\n            return -1;\n        // Scanning back to the next link/image start marker\n        for (let i = cx.parts.length - 1; i >= 0; i--) {\n            let part = cx.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart)) {\n                // If this one has been set invalid (because it would produce\n                // a nested link) or there's no valid link here ignore both.\n                if (!part.side || cx.skipSpace(part.to) == start && !/[(\\[]/.test(cx.slice(start + 1, start + 2))) {\n                    cx.parts[i] = null;\n                    return -1;\n                }\n                // Finish the content and replace the entire range in\n                // this.parts with the link/image node.\n                let content = cx.takeContent(i);\n                let link = cx.parts[i] = finishLink(cx, content, part.type == LinkStart ? Type.Link : Type.Image, part.from, start + 1);\n                // Set any open-link markers before this link to invalid.\n                if (part.type == LinkStart)\n                    for (let j = 0; j < i; j++) {\n                        let p = cx.parts[j];\n                        if (p instanceof InlineDelimiter && p.type == LinkStart)\n                            p.side = 0 /* Mark.None */;\n                    }\n                return link.to;\n            }\n        }\n        return -1;\n    }\n};\nfunction finishLink(cx, content, type, start, startPos) {\n    let { text } = cx, next = cx.char(startPos), endPos = startPos;\n    content.unshift(elt(Type.LinkMark, start, start + (type == Type.Image ? 2 : 1)));\n    content.push(elt(Type.LinkMark, startPos - 1, startPos));\n    if (next == 40 /* '(' */) {\n        let pos = cx.skipSpace(startPos + 1);\n        let dest = parseURL(text, pos - cx.offset, cx.offset), title;\n        if (dest) {\n            pos = cx.skipSpace(dest.to);\n            // The destination and title must be separated by whitespace\n            if (pos != dest.to) {\n                title = parseLinkTitle(text, pos - cx.offset, cx.offset);\n                if (title)\n                    pos = cx.skipSpace(title.to);\n            }\n        }\n        if (cx.char(pos) == 41 /* ')' */) {\n            content.push(elt(Type.LinkMark, startPos, startPos + 1));\n            endPos = pos + 1;\n            if (dest)\n                content.push(dest);\n            if (title)\n                content.push(title);\n            content.push(elt(Type.LinkMark, pos, endPos));\n        }\n    }\n    else if (next == 91 /* '[' */) {\n        let label = parseLinkLabel(text, startPos - cx.offset, cx.offset, false);\n        if (label) {\n            content.push(label);\n            endPos = label.to;\n        }\n    }\n    return elt(type, start, endPos, content);\n}\n// These return `null` when falling off the end of the input, `false`\n// when parsing fails otherwise (for use in the incremental link\n// reference parser).\nfunction parseURL(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next == 60 /* '<' */) {\n        for (let pos = start + 1; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (ch == 62 /* '>' */)\n                return elt(Type.URL, start + offset, pos + 1 + offset);\n            if (ch == 60 || ch == 10 /* '<\\n' */)\n                return false;\n        }\n        return null;\n    }\n    else {\n        let depth = 0, pos = start;\n        for (let escaped = false; pos < text.length; pos++) {\n            let ch = text.charCodeAt(pos);\n            if (space(ch)) {\n                break;\n            }\n            else if (escaped) {\n                escaped = false;\n            }\n            else if (ch == 40 /* '(' */) {\n                depth++;\n            }\n            else if (ch == 41 /* ')' */) {\n                if (!depth)\n                    break;\n                depth--;\n            }\n            else if (ch == 92 /* '\\\\' */) {\n                escaped = true;\n            }\n        }\n        return pos > start ? elt(Type.URL, start + offset, pos + offset) : pos == text.length ? null : false;\n    }\n}\nfunction parseLinkTitle(text, start, offset) {\n    let next = text.charCodeAt(start);\n    if (next != 39 && next != 34 && next != 40 /* '\"\\'(' */)\n        return false;\n    let end = next == 40 ? 41 : next;\n    for (let pos = start + 1, escaped = false; pos < text.length; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == end)\n            return elt(Type.LinkTitle, start + offset, pos + 1 + offset);\n        else if (ch == 92 /* '\\\\' */)\n            escaped = true;\n    }\n    return null;\n}\nfunction parseLinkLabel(text, start, offset, requireNonWS) {\n    for (let escaped = false, pos = start + 1, end = Math.min(text.length, pos + 999); pos < end; pos++) {\n        let ch = text.charCodeAt(pos);\n        if (escaped)\n            escaped = false;\n        else if (ch == 93 /* ']' */)\n            return requireNonWS ? false : elt(Type.LinkLabel, start + offset, pos + 1 + offset);\n        else {\n            if (requireNonWS && !space(ch))\n                requireNonWS = false;\n            if (ch == 91 /* '[' */)\n                return false;\n            else if (ch == 92 /* '\\\\' */)\n                escaped = true;\n        }\n    }\n    return null;\n}\n/**\nInline parsing functions get access to this context, and use it to\nread the content and emit syntax nodes.\n*/\nclass InlineContext {\n    /**\n    @internal\n    */\n    constructor(\n    /**\n    The parser that is being used.\n    */\n    parser, \n    /**\n    The text of this inline section.\n    */\n    text, \n    /**\n    The starting offset of the section in the document.\n    */\n    offset) {\n        this.parser = parser;\n        this.text = text;\n        this.offset = offset;\n        /**\n        @internal\n        */\n        this.parts = [];\n    }\n    /**\n    Get the character code at the given (document-relative)\n    position.\n    */\n    char(pos) { return pos >= this.end ? -1 : this.text.charCodeAt(pos - this.offset); }\n    /**\n    The position of the end of this inline section.\n    */\n    get end() { return this.offset + this.text.length; }\n    /**\n    Get a substring of this inline section. Again uses\n    document-relative positions.\n    */\n    slice(from, to) { return this.text.slice(from - this.offset, to - this.offset); }\n    /**\n    @internal\n    */\n    append(elt) {\n        this.parts.push(elt);\n        return elt.to;\n    }\n    /**\n    Add a [delimiter](#DelimiterType) at this given position. `open`\n    and `close` indicate whether this delimiter is opening, closing,\n    or both. Returns the end of the delimiter, for convenient\n    returning from [parse functions](#InlineParser.parse).\n    */\n    addDelimiter(type, from, to, open, close) {\n        return this.append(new InlineDelimiter(type, from, to, (open ? 1 /* Mark.Open */ : 0 /* Mark.None */) | (close ? 2 /* Mark.Close */ : 0 /* Mark.None */)));\n    }\n    /**\n    Returns true when there is an unmatched link or image opening\n    token before the current position.\n    */\n    get hasOpenLink() {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && (part.type == LinkStart || part.type == ImageStart))\n                return true;\n        }\n        return false;\n    }\n    /**\n    Add an inline element. Returns the end of the element.\n    */\n    addElement(elt) {\n        return this.append(elt);\n    }\n    /**\n    Resolve markers between this.parts.length and from, wrapping matched markers in the\n    appropriate node and updating the content of this.parts. @internal\n    */\n    resolveMarkers(from) {\n        // Scan forward, looking for closing tokens\n        for (let i = from; i < this.parts.length; i++) {\n            let close = this.parts[i];\n            if (!(close instanceof InlineDelimiter && close.type.resolve && (close.side & 2 /* Mark.Close */)))\n                continue;\n            let emp = close.type == EmphasisUnderscore || close.type == EmphasisAsterisk;\n            let closeSize = close.to - close.from;\n            let open, j = i - 1;\n            // Continue scanning for a matching opening token\n            for (; j >= from; j--) {\n                let part = this.parts[j];\n                if (part instanceof InlineDelimiter && (part.side & 1 /* Mark.Open */) && part.type == close.type &&\n                    // Ignore emphasis delimiters where the character count doesn't match\n                    !(emp && ((close.side & 1 /* Mark.Open */) || (part.side & 2 /* Mark.Close */)) &&\n                        (part.to - part.from + closeSize) % 3 == 0 && ((part.to - part.from) % 3 || closeSize % 3))) {\n                    open = part;\n                    break;\n                }\n            }\n            if (!open)\n                continue;\n            let type = close.type.resolve, content = [];\n            let start = open.from, end = close.to;\n            // Emphasis marker effect depends on the character count. Size consumed is minimum of the two\n            // markers.\n            if (emp) {\n                let size = Math.min(2, open.to - open.from, closeSize);\n                start = open.to - size;\n                end = close.from + size;\n                type = size == 1 ? \"Emphasis\" : \"StrongEmphasis\";\n            }\n            // Move the covered region into content, optionally adding marker nodes\n            if (open.type.mark)\n                content.push(this.elt(open.type.mark, start, open.to));\n            for (let k = j + 1; k < i; k++) {\n                if (this.parts[k] instanceof Element)\n                    content.push(this.parts[k]);\n                this.parts[k] = null;\n            }\n            if (close.type.mark)\n                content.push(this.elt(close.type.mark, close.from, end));\n            let element = this.elt(type, start, end, content);\n            // If there are leftover emphasis marker characters, shrink the close/open markers. Otherwise, clear them.\n            this.parts[j] = emp && open.from != start ? new InlineDelimiter(open.type, open.from, start, open.side) : null;\n            let keep = this.parts[i] = emp && close.to != end ? new InlineDelimiter(close.type, end, close.to, close.side) : null;\n            // Insert the new element in this.parts\n            if (keep)\n                this.parts.splice(i, 0, element);\n            else\n                this.parts[i] = element;\n        }\n        // Collect the elements remaining in this.parts into an array.\n        let result = [];\n        for (let i = from; i < this.parts.length; i++) {\n            let part = this.parts[i];\n            if (part instanceof Element)\n                result.push(part);\n        }\n        return result;\n    }\n    /**\n    Find an opening delimiter of the given type. Returns `null` if\n    no delimiter is found, or an index that can be passed to\n    [`takeContent`](#InlineContext.takeContent) otherwise.\n    */\n    findOpeningDelimiter(type) {\n        for (let i = this.parts.length - 1; i >= 0; i--) {\n            let part = this.parts[i];\n            if (part instanceof InlineDelimiter && part.type == type)\n                return i;\n        }\n        return null;\n    }\n    /**\n    Remove all inline elements and delimiters starting from the\n    given index (which you should get from\n    [`findOpeningDelimiter`](#InlineContext.findOpeningDelimiter),\n    resolve delimiters inside of them, and return them as an array\n    of elements.\n    */\n    takeContent(startIndex) {\n        let content = this.resolveMarkers(startIndex);\n        this.parts.length = startIndex;\n        return content;\n    }\n    /**\n    Skip space after the given (document) position, returning either\n    the position of the next non-space character or the end of the\n    section.\n    */\n    skipSpace(from) { return skipSpace(this.text, from - this.offset) + this.offset; }\n    elt(type, from, to, children) {\n        if (typeof type == \"string\")\n            return elt(this.parser.getNodeType(type), from, to, children);\n        return new TreeElement(type, from);\n    }\n}\nfunction injectMarks(elements, marks) {\n    if (!marks.length)\n        return elements;\n    if (!elements.length)\n        return marks;\n    let elts = elements.slice(), eI = 0;\n    for (let mark of marks) {\n        while (eI < elts.length && elts[eI].to < mark.to)\n            eI++;\n        if (eI < elts.length && elts[eI].from < mark.from) {\n            let e = elts[eI];\n            if (e instanceof Element)\n                elts[eI] = new Element(e.type, e.from, e.to, injectMarks(e.children, [mark]));\n        }\n        else {\n            elts.splice(eI++, 0, mark);\n        }\n    }\n    return elts;\n}\n// These are blocks that can span blank lines, and should thus only be\n// reused if their next sibling is also being reused.\nconst NotLast = [Type.CodeBlock, Type.ListItem, Type.OrderedList, Type.BulletList];\nclass FragmentCursor {\n    constructor(fragments, input) {\n        this.fragments = fragments;\n        this.input = input;\n        // Index into fragment array\n        this.i = 0;\n        // Active fragment\n        this.fragment = null;\n        this.fragmentEnd = -1;\n        // Cursor into the current fragment, if any. When `moveTo` returns\n        // true, this points at the first block after `pos`.\n        this.cursor = null;\n        if (fragments.length)\n            this.fragment = fragments[this.i++];\n    }\n    nextFragment() {\n        this.fragment = this.i < this.fragments.length ? this.fragments[this.i++] : null;\n        this.cursor = null;\n        this.fragmentEnd = -1;\n    }\n    moveTo(pos, lineStart) {\n        while (this.fragment && this.fragment.to <= pos)\n            this.nextFragment();\n        if (!this.fragment || this.fragment.from > (pos ? pos - 1 : 0))\n            return false;\n        if (this.fragmentEnd < 0) {\n            let end = this.fragment.to;\n            while (end > 0 && this.input.read(end - 1, end) != \"\\n\")\n                end--;\n            this.fragmentEnd = end ? end - 1 : 0;\n        }\n        let c = this.cursor;\n        if (!c) {\n            c = this.cursor = this.fragment.tree.cursor();\n            c.firstChild();\n        }\n        let rPos = pos + this.fragment.offset;\n        while (c.to <= rPos)\n            if (!c.parent())\n                return false;\n        for (;;) {\n            if (c.from >= rPos)\n                return this.fragment.from <= lineStart;\n            if (!c.childAfter(rPos))\n                return false;\n        }\n    }\n    matches(hash) {\n        let tree = this.cursor.tree;\n        return tree && tree.prop(NodeProp.contextHash) == hash;\n    }\n    takeNodes(cx) {\n        let cur = this.cursor, off = this.fragment.offset, fragEnd = this.fragmentEnd - (this.fragment.openEnd ? 1 : 0);\n        let start = cx.absoluteLineStart, end = start, blockI = cx.block.children.length;\n        let prevEnd = end, prevI = blockI;\n        for (;;) {\n            if (cur.to - off > fragEnd) {\n                if (cur.type.isAnonymous && cur.firstChild())\n                    continue;\n                break;\n            }\n            let pos = toRelative(cur.from - off, cx.ranges);\n            if (cur.to - off <= cx.ranges[cx.rangeI].to) { // Fits in current range\n                cx.addNode(cur.tree, pos);\n            }\n            else {\n                let dummy = new Tree(cx.parser.nodeSet.types[Type.Paragraph], [], [], 0, cx.block.hashProp);\n                cx.reusePlaceholders.set(dummy, cur.tree);\n                cx.addNode(dummy, pos);\n            }\n            // Taken content must always end in a block, because incremental\n            // parsing happens on block boundaries. Never stop directly\n            // after an indented code block, since those can continue after\n            // any number of blank lines.\n            if (cur.type.is(\"Block\")) {\n                if (NotLast.indexOf(cur.type.id) < 0) {\n                    end = cur.to - off;\n                    blockI = cx.block.children.length;\n                }\n                else {\n                    end = prevEnd;\n                    blockI = prevI;\n                    prevEnd = cur.to - off;\n                    prevI = cx.block.children.length;\n                }\n            }\n            if (!cur.nextSibling())\n                break;\n        }\n        while (cx.block.children.length > blockI) {\n            cx.block.children.pop();\n            cx.block.positions.pop();\n        }\n        return end - start;\n    }\n}\n// Convert an input-stream-relative position to a\n// Markdown-doc-relative position by subtracting the size of all input\n// gaps before `abs`.\nfunction toRelative(abs, ranges) {\n    let pos = abs;\n    for (let i = 1; i < ranges.length; i++) {\n        let gapFrom = ranges[i - 1].to, gapTo = ranges[i].from;\n        if (gapFrom < abs)\n            pos -= gapTo - gapFrom;\n    }\n    return pos;\n}\nconst markdownHighlighting = styleTags({\n    \"Blockquote/...\": tags.quote,\n    HorizontalRule: tags.contentSeparator,\n    \"ATXHeading1/... SetextHeading1/...\": tags.heading1,\n    \"ATXHeading2/... SetextHeading2/...\": tags.heading2,\n    \"ATXHeading3/...\": tags.heading3,\n    \"ATXHeading4/...\": tags.heading4,\n    \"ATXHeading5/...\": tags.heading5,\n    \"ATXHeading6/...\": tags.heading6,\n    \"Comment CommentBlock\": tags.comment,\n    Escape: tags.escape,\n    Entity: tags.character,\n    \"Emphasis/...\": tags.emphasis,\n    \"StrongEmphasis/...\": tags.strong,\n    \"Link/... Image/...\": tags.link,\n    \"OrderedList/... BulletList/...\": tags.list,\n    \"BlockQuote/...\": tags.quote,\n    \"InlineCode CodeText\": tags.monospace,\n    \"URL Autolink\": tags.url,\n    \"HeaderMark HardBreak QuoteMark ListMark LinkMark EmphasisMark CodeMark\": tags.processingInstruction,\n    \"CodeInfo LinkLabel\": tags.labelName,\n    LinkTitle: tags.string,\n    Paragraph: tags.content\n});\n/**\nThe default CommonMark parser.\n*/\nconst parser = new MarkdownParser(new NodeSet(nodeTypes).extend(markdownHighlighting), Object.keys(DefaultBlockParsers).map(n => DefaultBlockParsers[n]), Object.keys(DefaultBlockParsers).map(n => DefaultLeafBlocks[n]), Object.keys(DefaultBlockParsers), DefaultEndLeaf, DefaultSkipMarkup, Object.keys(DefaultInline).map(n => DefaultInline[n]), Object.keys(DefaultInline), []);\n\nfunction leftOverSpace(node, from, to) {\n    let ranges = [];\n    for (let n = node.firstChild, pos = from;; n = n.nextSibling) {\n        let nextPos = n ? n.from : to;\n        if (nextPos > pos)\n            ranges.push({ from: pos, to: nextPos });\n        if (!n)\n            break;\n        pos = n.to;\n    }\n    return ranges;\n}\n/**\nCreate a Markdown extension to enable nested parsing on code\nblocks and/or embedded HTML.\n*/\nfunction parseCode(config) {\n    let { codeParser, htmlParser } = config;\n    let wrap = parseMixed((node, input) => {\n        let id = node.type.id;\n        if (codeParser && (id == Type.CodeBlock || id == Type.FencedCode)) {\n            let info = \"\";\n            if (id == Type.FencedCode) {\n                let infoNode = node.node.getChild(Type.CodeInfo);\n                if (infoNode)\n                    info = input.read(infoNode.from, infoNode.to);\n            }\n            let parser = codeParser(info);\n            if (parser)\n                return { parser, overlay: node => node.type.id == Type.CodeText };\n        }\n        else if (htmlParser && (id == Type.HTMLBlock || id == Type.HTMLTag || id == Type.CommentBlock)) {\n            return { parser: htmlParser, overlay: leftOverSpace(node.node, node.from, node.to) };\n        }\n        return null;\n    });\n    return { wrap };\n}\n\nconst StrikethroughDelim = { resolve: \"Strikethrough\", mark: \"StrikethroughMark\" };\n/**\nAn extension that implements\n[GFM-style](https://github.github.com/gfm/#strikethrough-extension-)\nStrikethrough syntax using `~~` delimiters.\n*/\nconst Strikethrough = {\n    defineNodes: [{\n            name: \"Strikethrough\",\n            style: { \"Strikethrough/...\": tags.strikethrough }\n        }, {\n            name: \"StrikethroughMark\",\n            style: tags.processingInstruction\n        }],\n    parseInline: [{\n            name: \"Strikethrough\",\n            parse(cx, next, pos) {\n                if (next != 126 /* '~' */ || cx.char(pos + 1) != 126 || cx.char(pos + 2) == 126)\n                    return -1;\n                let before = cx.slice(pos - 1, pos), after = cx.slice(pos + 2, pos + 3);\n                let sBefore = /\\s|^$/.test(before), sAfter = /\\s|^$/.test(after);\n                let pBefore = Punctuation.test(before), pAfter = Punctuation.test(after);\n                return cx.addDelimiter(StrikethroughDelim, pos, pos + 2, !sAfter && (!pAfter || sBefore || pBefore), !sBefore && (!pBefore || sAfter || pAfter));\n            },\n            after: \"Emphasis\"\n        }]\n};\n// Parse a line as a table row and return the row count. When `elts`\n// is given, push syntax elements for the content onto it.\nfunction parseRow(cx, line, startI = 0, elts, offset = 0) {\n    let count = 0, first = true, cellStart = -1, cellEnd = -1, esc = false;\n    let parseCell = () => {\n        elts.push(cx.elt(\"TableCell\", offset + cellStart, offset + cellEnd, cx.parser.parseInline(line.slice(cellStart, cellEnd), offset + cellStart)));\n    };\n    for (let i = startI; i < line.length; i++) {\n        let next = line.charCodeAt(i);\n        if (next == 124 /* '|' */ && !esc) {\n            if (!first || cellStart > -1)\n                count++;\n            first = false;\n            if (elts) {\n                if (cellStart > -1)\n                    parseCell();\n                elts.push(cx.elt(\"TableDelimiter\", i + offset, i + offset + 1));\n            }\n            cellStart = cellEnd = -1;\n        }\n        else if (esc || next != 32 && next != 9) {\n            if (cellStart < 0)\n                cellStart = i;\n            cellEnd = i + 1;\n        }\n        esc = !esc && next == 92;\n    }\n    if (cellStart > -1) {\n        count++;\n        if (elts)\n            parseCell();\n    }\n    return count;\n}\nfunction hasPipe(str, start) {\n    for (let i = start; i < str.length; i++) {\n        let next = str.charCodeAt(i);\n        if (next == 124 /* '|' */)\n            return true;\n        if (next == 92 /* '\\\\' */)\n            i++;\n    }\n    return false;\n}\nconst delimiterLine = /^\\|?(\\s*:?-+:?\\s*\\|)+(\\s*:?-+:?\\s*)?$/;\nclass TableParser {\n    constructor() {\n        // Null means we haven't seen the second line yet, false means this\n        // isn't a table, and an array means this is a table and we've\n        // parsed the given rows so far.\n        this.rows = null;\n    }\n    nextLine(cx, line, leaf) {\n        if (this.rows == null) { // Second line\n            this.rows = false;\n            let lineText;\n            if ((line.next == 45 || line.next == 58 || line.next == 124 /* '-:|' */) &&\n                delimiterLine.test(lineText = line.text.slice(line.pos))) {\n                let firstRow = [], firstCount = parseRow(cx, leaf.content, 0, firstRow, leaf.start);\n                if (firstCount == parseRow(cx, lineText, line.pos))\n                    this.rows = [cx.elt(\"TableHeader\", leaf.start, leaf.start + leaf.content.length, firstRow),\n                        cx.elt(\"TableDelimiter\", cx.lineStart + line.pos, cx.lineStart + line.text.length)];\n            }\n        }\n        else if (this.rows) { // Line after the second\n            let content = [];\n            parseRow(cx, line.text, line.pos, content, cx.lineStart);\n            this.rows.push(cx.elt(\"TableRow\", cx.lineStart + line.pos, cx.lineStart + line.text.length, content));\n        }\n        return false;\n    }\n    finish(cx, leaf) {\n        if (!this.rows)\n            return false;\n        cx.addLeafElement(leaf, cx.elt(\"Table\", leaf.start, leaf.start + leaf.content.length, this.rows));\n        return true;\n    }\n}\n/**\nThis extension provides\n[GFM-style](https://github.github.com/gfm/#tables-extension-)\ntables, using syntax like this:\n\n```\n| head 1 | head 2 |\n| ---    | ---    |\n| cell 1 | cell 2 |\n```\n*/\nconst Table = {\n    defineNodes: [\n        { name: \"Table\", block: true },\n        { name: \"TableHeader\", style: { \"TableHeader/...\": tags.heading } },\n        \"TableRow\",\n        { name: \"TableCell\", style: tags.content },\n        { name: \"TableDelimiter\", style: tags.processingInstruction },\n    ],\n    parseBlock: [{\n            name: \"Table\",\n            leaf(_, leaf) { return hasPipe(leaf.content, 0) ? new TableParser : null; },\n            endLeaf(cx, line, leaf) {\n                if (leaf.parsers.some(p => p instanceof TableParser) || !hasPipe(line.text, line.basePos))\n                    return false;\n                let next = cx.peekLine();\n                return delimiterLine.test(next) && parseRow(cx, line.text, line.basePos) == parseRow(cx, next, line.basePos);\n            },\n            before: \"SetextHeading\"\n        }]\n};\nclass TaskParser {\n    nextLine() { return false; }\n    finish(cx, leaf) {\n        cx.addLeafElement(leaf, cx.elt(\"Task\", leaf.start, leaf.start + leaf.content.length, [\n            cx.elt(\"TaskMarker\", leaf.start, leaf.start + 3),\n            ...cx.parser.parseInline(leaf.content.slice(3), leaf.start + 3)\n        ]));\n        return true;\n    }\n}\n/**\nExtension providing\n[GFM-style](https://github.github.com/gfm/#task-list-items-extension-)\ntask list items, where list items can be prefixed with `[ ]` or\n`[x]` to add a checkbox.\n*/\nconst TaskList = {\n    defineNodes: [\n        { name: \"Task\", block: true, style: tags.list },\n        { name: \"TaskMarker\", style: tags.atom }\n    ],\n    parseBlock: [{\n            name: \"TaskList\",\n            leaf(cx, leaf) {\n                return /^\\[[ xX]\\][ \\t]/.test(leaf.content) && cx.parentType().name == \"ListItem\" ? new TaskParser : null;\n            },\n            after: \"SetextHeading\"\n        }]\n};\nconst autolinkRE = /(www\\.)|(https?:\\/\\/)|([\\w.+-]{1,100}@)|(mailto:|xmpp:)/gy;\nconst urlRE = /[\\w-]+(\\.[\\w-]+)+(\\/[^\\s<]*)?/gy;\nconst lastTwoDomainWords = /[\\w-]+\\.[\\w-]+($|\\/)/;\nconst emailRE = /[\\w.+-]+@[\\w-]+(\\.[\\w.-]+)+/gy;\nconst xmppResourceRE = /\\/[a-zA-Z\\d@.]+/gy;\nfunction count(str, from, to, ch) {\n    let result = 0;\n    for (let i = from; i < to; i++)\n        if (str[i] == ch)\n            result++;\n    return result;\n}\nfunction autolinkURLEnd(text, from) {\n    urlRE.lastIndex = from;\n    let m = urlRE.exec(text);\n    if (!m || lastTwoDomainWords.exec(m[0])[0].indexOf(\"_\") > -1)\n        return -1;\n    let end = from + m[0].length;\n    for (;;) {\n        let last = text[end - 1], m;\n        if (/[?!.,:*_~]/.test(last) ||\n            last == \")\" && count(text, from, end, \")\") > count(text, from, end, \"(\"))\n            end--;\n        else if (last == \";\" && (m = /&(?:#\\d+|#x[a-f\\d]+|\\w+);$/.exec(text.slice(from, end))))\n            end = from + m.index;\n        else\n            break;\n    }\n    return end;\n}\nfunction autolinkEmailEnd(text, from) {\n    emailRE.lastIndex = from;\n    let m = emailRE.exec(text);\n    if (!m)\n        return -1;\n    let last = m[0][m[0].length - 1];\n    return last == \"_\" || last == \"-\" ? -1 : from + m[0].length - (last == \".\" ? 1 : 0);\n}\n/**\nExtension that implements autolinking for\n`www.`/`http://`/`https://`/`mailto:`/`xmpp:` URLs and email\naddresses.\n*/\nconst Autolink = {\n    parseInline: [{\n            name: \"Autolink\",\n            parse(cx, next, absPos) {\n                let pos = absPos - cx.offset;\n                if (pos && /\\w/.test(cx.text[pos - 1]))\n                    return -1;\n                autolinkRE.lastIndex = pos;\n                let m = autolinkRE.exec(cx.text), end = -1;\n                if (!m)\n                    return -1;\n                if (m[1] || m[2]) { // www., http://\n                    end = autolinkURLEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && cx.hasOpenLink) {\n                        let noBracket = /([^\\[\\]]|\\[[^\\]]*\\])*/.exec(cx.text.slice(pos, end));\n                        end = pos + noBracket[0].length;\n                    }\n                }\n                else if (m[3]) { // email address\n                    end = autolinkEmailEnd(cx.text, pos);\n                }\n                else { // mailto:/xmpp:\n                    end = autolinkEmailEnd(cx.text, pos + m[0].length);\n                    if (end > -1 && m[0] == \"xmpp:\") {\n                        xmppResourceRE.lastIndex = end;\n                        m = xmppResourceRE.exec(cx.text);\n                        if (m)\n                            end = m.index + m[0].length;\n                    }\n                }\n                if (end < 0)\n                    return -1;\n                cx.addElement(cx.elt(\"URL\", absPos, end + cx.offset));\n                return end + cx.offset;\n            }\n        }]\n};\n/**\nExtension bundle containing [`Table`](#Table),\n[`TaskList`](#TaskList), [`Strikethrough`](#Strikethrough), and\n[`Autolink`](#Autolink).\n*/\nconst GFM = [Table, TaskList, Strikethrough, Autolink];\nfunction parseSubSuper(ch, node, mark) {\n    return (cx, next, pos) => {\n        if (next != ch || cx.char(pos + 1) == ch)\n            return -1;\n        let elts = [cx.elt(mark, pos, pos + 1)];\n        for (let i = pos + 1; i < cx.end; i++) {\n            let next = cx.char(i);\n            if (next == ch)\n                return cx.addElement(cx.elt(node, pos, i + 1, elts.concat(cx.elt(mark, i, i + 1))));\n            if (next == 92 /* '\\\\' */)\n                elts.push(cx.elt(\"Escape\", i, i++ + 2));\n            if (space(next))\n                break;\n        }\n        return -1;\n    };\n}\n/**\nExtension providing\n[Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\nsuperscript using `^` markers.\n*/\nconst Superscript = {\n    defineNodes: [\n        { name: \"Superscript\", style: tags.special(tags.content) },\n        { name: \"SuperscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Superscript\",\n            parse: parseSubSuper(94 /* '^' */, \"Superscript\", \"SuperscriptMark\")\n        }]\n};\n/**\nExtension providing\n[Pandoc-style](https://pandoc.org/MANUAL.html#superscripts-and-subscripts)\nsubscript using `~` markers.\n*/\nconst Subscript = {\n    defineNodes: [\n        { name: \"Subscript\", style: tags.special(tags.content) },\n        { name: \"SubscriptMark\", style: tags.processingInstruction }\n    ],\n    parseInline: [{\n            name: \"Subscript\",\n            parse: parseSubSuper(126 /* '~' */, \"Subscript\", \"SubscriptMark\")\n        }]\n};\n/**\nExtension that parses two colons with only letters, underscores,\nand numbers between them as `Emoji` nodes.\n*/\nconst Emoji = {\n    defineNodes: [{ name: \"Emoji\", style: tags.character }],\n    parseInline: [{\n            name: \"Emoji\",\n            parse(cx, next, pos) {\n                let match;\n                if (next != 58 /* ':' */ || !(match = /^[a-zA-Z_0-9]+:/.exec(cx.slice(pos + 1, cx.end))))\n                    return -1;\n                return cx.addElement(cx.elt(\"Emoji\", pos, pos + 1 + match[0].length));\n            }\n        }]\n};\n\nexport { Autolink, BlockContext, Element, Emoji, GFM, InlineContext, LeafBlock, Line, MarkdownParser, Strikethrough, Subscript, Superscript, Table, TaskList, parseCode, parser };\n"],"names":["Type","CompositeBlock","create","type","value","from","parentHash","end","constructor","hash","children","positions","this","hashProp","contextHash","addChild","child","pos","prop","length","push","toTree","nodeSet","last","Math","max","types","balance","makeTree","none","LeafBlock","start","content","marks","parsers","Line","text","baseIndent","basePos","depth","markers","indent","next","forward","forwardInner","newPos","skipSpace","countIndent","charCodeAt","reset","pop","moveBase","to","moveBaseColumn","findColumn","addMarker","elt","i","goal","scrub","result","slice","skipForList","bl","cx","line","block","stack","size","OrderedList","isOrderedList","isBulletList","BulletList","isHorizontalRule","DefaultSkipMarkup","Blockquote","QuoteMark","lineStart","space","ListItem","_cx","Document","ch","skipSpaceBack","isFencedCode","isBlockquote","breaking","count","isSetextUnderline","parser","leafBlockParsers","indexOf","DefaultLeafBlocks","SetextHeading","inList","isAtxHeading","EmptyLine","CommentEnd","ProcessingEnd","HTMLBlockStyle","isHTMLBlock","rest","e","test","getListIndent","indentAfter","indented","addCodeText","CodeText","DefaultBlockParsers","LinkReference","undefined","IndentedCode","base","pendingMarks","nextLine","m","codeStart","filter","concat","addNode","buffer","writeElements","finish","CodeBlock","FencedCode","fenceEnd","len","infoFrom","infoTo","CodeMark","CodeInfo","first","textStart","textEnd","prevLineEnd","startContext","HorizontalRule","newBase","ListMark","ATXHeading","off","endOfSpace","after","buf","write","HeaderMark","parseInline","node","ATXHeading1","HTMLBlock","trailing","nodeType","CommentBlock","ProcessingInstructionBlock","LinkReferenceParser","leaf","stage","elts","advance","complete","addLeafElement","nextStage","parseLinkLabel","LinkMark","skip","title","parseLinkTitle","titleEnd","lineEnd","parseURL","SetextHeadingParser","underline","underlineMark","SetextHeading1","SetextHeading2","_","DefaultEndLeaf","p","scanLineResult","BlockContext","input","fragments","ranges","atEnd","reusePlaceholders","Map","stoppedAt","rangeI","absoluteLineStart","absoluteLineEnd","FragmentCursor","readLine","parsedPos","markI","mark","finishContext","reuseFragment","blockParsers","parse","lines","stop","endLeafBlock","finishLeaf","stopAt","RangeError","moveTo","matches","taken","takeNodes","toRelative","moveRangeI","parentType","peekLine","scanLine","r","lineChunkAt","textOffset","nextFrom","handler","skipContextMarkup","Error","chunk","lineChunks","eol","startComposite","getNodeType","addElement","injectMarks","top","addGaps","tree","injectGaps","topNode","inline","Paragraph","TreeElement","Buffer","offset","dummies","rangeEnd","movePastNext","upto","inclusive","firstChild","nextSibling","reuse","get","propValues","MarkdownParser","blockNames","inlineParsers","inlineNames","wrappers","super","nodeTypes","Object","t","name","id","createParse","w","configure","spec","config","resolveConfig","nonEmpty","defineNodes","assign","styles","s","composite","style","some","group","define","props","Array","isArray","extend","remove","rm","parseBlock","found","before","findName","splice","endLeaf","wrap","InlineContext","outer","char","token","resolveMarkers","a","conf","conc","b","wrapA","wrapB","inner","names","Escape","nodes","writeTo","build","reused","topID","Element","startOff","EmphasisUnderscore","resolve","EmphasisAsterisk","LinkStart","ImageStart","InlineDelimiter","side","Punctuation","RegExp","DefaultInline","escaped","Escapable","append","Entity","exec","InlineCode","curSize","HTMLTag","url","Autolink","URL","comment","Comment","procInst","ProcessingInstruction","Emphasis","pBefore","pAfter","sBefore","sAfter","leftFlanking","rightFlanking","canOpen","canClose","HardBreak","Link","Image","LinkEnd","parts","part","takeContent","link","finishLink","j","startPos","endPos","unshift","dest","label","LinkTitle","requireNonWS","min","LinkLabel","addDelimiter","open","close","hasOpenLink","emp","closeSize","k","element","findOpeningDelimiter","startIndex","elements","eI","NotLast","fragment","fragmentEnd","cursor","nextFragment","read","c","rPos","parent","childAfter","cur","fragEnd","openEnd","blockI","prevEnd","prevI","isAnonymous","dummy","set","is","abs","gapFrom","gapTo","markdownHighlighting","quote","contentSeparator","heading1","heading2","heading3","heading4","heading5","heading6","escape","character","emphasis","strong","list","monospace","processingInstruction","labelName","string","keys","map","n","leftOverSpace","nextPos","parseCode","codeParser","htmlParser","overlay","info","infoNode","getChild","StrikethroughDelim","Strikethrough","strikethrough","parseRow","startI","cellStart","cellEnd","esc","parseCell","hasPipe","str","delimiterLine","TableParser","rows","lineText","firstRow","Table","heading","TaskParser","TaskList","atom","autolinkRE","urlRE","lastTwoDomainWords","emailRE","xmppResourceRE","autolinkEmailEnd","lastIndex","GFM","absPos","index","autolinkURLEnd","parseSubSuper","Superscript","special","Subscript","Emoji","match"],"sourceRoot":""}